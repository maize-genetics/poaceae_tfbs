---
title: "Run global association models"
output: html_notebook
---
```{r, echo = F}
knitr::opts_chunk$set(
  fig.width = 10,  # Set the desired width
  fig.height = 6,  # Set the desired height
  dpi = 1000        # Set the resolution to 300 DPI
)
```

```{r, echo = F}
library(ggpubr)
library(data.table)
library(rstatix)
library(parallel)
library(qqman)
library(knitr)
library(doParallel)
library(ape)
library(pheatmap)
library(ggridges)
library(tidyverse)
```

```{r}
# Load covariates
rootDir= "/workdir/coh22/poaceae_tfbs/"
# Load metadata
metadata <- read.csv(paste0(rootDir, "data/Poaceae_metadata_2025.04.07_CH.csv"))

# Load environmental data and add assemblyID
env <- read.table(paste0(rootDir, "output/modelData/envData_759Poaceae_20240821.txt")) %>%
  mutate(assemblyID = rownames(.))

# Load phylogenetic kernel matrix
phyloK <- read.table(paste0(rootDir, "output/modelData/phyloK_728Poaceae_astral_20250407.txt"))
colnames(phyloK) <- rownames(phyloK)

# Load phylogenetic tree
tree <- read.tree(paste0(rootDir, "output/modelData/PoaceaeTree_angiosperm353_astral_filtered_20250407.nwk"))

# Load nucleotide frequencies
nucFreqs <- read.csv(paste0(rootDir, "output/modelData/nucFreqs_shortIntrons.csv"))
```

Calculate environmental residuals for ePC1 after controlling for phylogeny
``` {r}
library(asreml)
env_for_model <- mutate(env, assemblyID = as.factor(assemblyID))
envPC1_resids <- asreml(envPC_1 ~ 1, random = ~ vm(assemblyID, phyloK), ai.sing = TRUE, data = env_for_model)
```

``` {r}
# Motifs
source(paste0(rootDir, "src/05_motifTurnover/load_motif_data.R"))  # Adjust the filename as needed
mat.list <- load_motif_data(
  unenriched_clusters_path = paste0(rootDir, "lists/unenriched_clusters.txt"),
  cluster_meta_path = paste0(rootDir, "data/JASPAR2024_SummarizedClusters.txt"),
  motifs_dir = paste0(rootDir, "output/motifOutput/motifs_by_orthogroup/filtered_OGs_200assemblies")
)

mats_to_df <- function(mat) {
  mat <- as.data.frame(mat)
  mat$assemblyID <- rownames(mat)
  return(mat)
}

df.list <- lapply(mat.list, mats_to_df)
# Combine into a single df
combined_df <- rbindlist(df.list, use.names = TRUE, fill = TRUE)
```

``` {r}
## Calculate motif occurrence rates for each assembly
all.motifs.by.taxa <- split(combined_df, combined_df$assemblyID)
og.counts <- lapply(all.motifs.by.taxa, nrow)

calculateMotifOccurrenceRates <- function(mat, og.count) {
  # Sum motifs across all orthogroups
  sums <- colSums(mat[,1:(ncol(mat) - 1)], na.rm = TRUE) # for candidate list
  # Divide by number of orthogroups represented in the assembly
  occurrence.rates <- sums / og.count
  # join with assemblyID
  results <- c(mat$assemblyID[1], occurrence.rates)
  results
  names(results)[1] <- "assemblyID"
  return(results)
}

all.motif.occurrence.list <- mapply(calculateMotifOccurrenceRates,  all.motifs.by.taxa, og.counts)
all.motif.occurrence.rates <- as.data.frame(t(all.motif.occurrence.list)) 
all.motif.occurrence.rates[,-1] <- sapply(all.motif.occurrence.rates[,-1], as.numeric)
# Calculate overall motif density for each assembly
motif.densities <- rowSums(all.motif.occurrence.rates[,2:ncol(all.motif.occurrence.rates)]) %>%
  as.data.frame()
motif.densities$assemblyID <- all.motif.occurrence.rates$assemblyID
names(motif.densities)[1] <- "global.motif.density"
rownames(motif.densities) <- motif.densities$assemblyID
```

``` {r}
library(dplyr)
library(asreml)
library(data.table)
library(ade4)
library(factoextra)

# Extract environmental PCs
EnvTraitMatrix <- env[,286:295] # first 10 ePCs
rownames(EnvTraitMatrix) <- env$assemblyID
# Generate nucFreq PCs as covariates
nucPC <- dudi.pca(nucFreqs[,-21], scannf = FALSE, nf = 20)
fviz_eig(nucPC) # See how much variance is explained by each PC axis - first explains 70%, first five explain nearly all
nucPCaxes <- nucPC$li[1:5]
rownames(nucPCaxes) <- nucFreqs$assemblyID
colnames(nucPCaxes) <- paste0("nucPC", 1:5)
nucPCaxes$assemblyID <- nucFreqs$assemblyID

# Find common taxa represented in motif, phyloK, and environment datasets
common_rows <- base::intersect(rownames(all.motif.occurrence.rates), rownames(phyloK)) %>%
  base::intersect(rownames(EnvTraitMatrix)) %>%
  base::intersect(nucPCaxes$assemblyID)   %>%
  sort()

# Filter to retain taxa shared across datasets
EnvTrait_filtered <- EnvTraitMatrix[common_rows,]
all.motif.occurrence.rates.filtered <- all.motif.occurrence.rates[common_rows,]
nucFreqs_filtered <- nucPCaxes[common_rows,]
Kphylo_filtered <- phyloK[common_rows, common_rows]
motif.densities_filtered <- motif.densities[common_rows,]

input_mat <- as.data.frame(cbind(EnvTrait_filtered, all.motif.occurrence.rates.filtered)) %>%
  left_join(nucFreqs_filtered) %>%
  left_join(motif.densities)
input_mat$assemblyID <- as.factor(rownames(all.motif.occurrence.rates.filtered))
setnames(input_mat, gsub("-", "_", names(input_mat))) # Remove hyphens from motif names to enable parsing by model

## Iterate over all motifs in matrix
motifModels <- list()
nMotifs <- ncol(all.motif.occurrence.rates.filtered) - 1
n_traits <- ncol(EnvTraitMatrix)
ePC_names <- colnames(EnvTraitMatrix)

for(j in 1:nMotifs){
  motifID <- colnames(input_mat)[j+1+n_traits]
  # Run association model for each motif
  formula_str <- paste(motifID, "~", paste(paste(ePC_names, collapse =" + "), collapse = " "), "+ global.motif.density + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5", collapse = "")
  formula_obj <- as.formula(formula_str)
  model <- asreml(fixed = formula_obj, random = ~ vm(assemblyID, Kphylo_filtered), ai.sing = TRUE, data = input_mat)
  # Extract model results
  modelSummary <- summary(model)
  loglik <- modelSummary$loglik
  phylo_explained <- modelSummary$varcomp$component[1] / sum(modelSummary$varcomp$component[1:2])
  modelWald <- wald.asreml(model)
  env_coeffs <- model$coefficients$fixed[2:(1 + n_traits)]
  env_pvals_log10p <- -(pchisq(modelWald[(2:(1 + n_traits)), 3], 1, log.p = TRUE, lower.tail = FALSE) / log(10))
  motifModels[[j]] <- list(motifID, phylo_explained, env_coeffs, env_pvals_log10p)
}


# Extract p values
model_output <- mclapply(motifModels, function(x) {
  x <- unlist(x)
  x <- t(x)
  x <- as.data.frame(x)
  names(x) <- c("motif", "phylo_explained", paste0("coef_ePC", 1:n_traits), paste0("log10pval_ePC", 1:n_traits))
  return(x)
}, mc.cores = detectCores() - 1)

results <- rbindlist(model_output, fill = T)# %>%
head(results)
results_df <- results %>%
  pivot_longer(
    cols = starts_with("coef") | starts_with("log10pval"),
    names_to = c(".value", "ePC"),
    names_pattern = "(coef|log10pval)_ePC(\\d+)"
  ) %>%
  arrange(motif, ePC) %>%
  as.data.frame() %>%
  dplyr::filter(phylo_explained < 0.95)

results_df[,c(2,4,5)] <- lapply(results_df[,c(2,4,5)], as.numeric)
results_df$pval <- 10^(-results_df$log10pval)
results_df$p.fdr <- p.adjust(results_df$pval, method = "fdr")
sorted_results <- arrange(results_df, desc(log10pval))

# Must supply named cols/rows with assembly IDs
write.table(sorted_results, file="/workdir/coh22/poaceae_tfbs/results/models/model_globalOcc_envPC1.10.csv", sep = ",", quote = F, row.names = F)
```

# Plot QQ plot
``` {r}
PlotQQ <- function(df) {
  # Create observed vs expected p values for plot
  observed_pvals = sort(df$log10pval, decreasing = T)
  observed_p.fdr = p.adjust(10^(-observed_pvals), method = "fdr")
  expected_pvals = qunif(seq(0, 1, length.out = length(observed_pvals) + 2), min = 0, max = 1)  ## Generate expected values. Note that we are using length+2
  expected_pvals = expected_pvals[expected_pvals != 0 & expected_pvals != 1]  ## Remove the two extra values since they are 0 and 1

  p_df = data.frame(observed = observed_pvals,
                    expected = -log10(expected_pvals),
                    color = ifelse(observed_p.fdr < 0.01, "goldenrod1", "#2C7BB6"))  # Assign color based on p.fdr
  
  ggplot(p_df, aes(x = expected, y = observed, color = color)) +
    geom_point(size = 7, alpha = 0.8) +  # Color determined by 'color' column
    scale_color_identity() +  # Use color values directly
    geom_abline(intercept = 0, slope = 1, color = '#D7191C', linetype = 'dashed', linewidth = 0.8) +  # Dashed red line
    labs(
      x = expression("-log"[10]~"Expected p-value"),
      y = expression("-log"[10]~"Observed p-value")
    ) +
    theme_minimal(base_size = 36) +  # Minimal theme for clean appearance
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),  # Center and bold title
      axis.title = element_text(face = "bold"),  # Bold axis titles
      panel.grid.major = element_line(linewidth = 0.5, color = 'grey80'),  # Light gray grid lines
      panel.grid.minor = element_blank()  # Remove minor grid lines
    )
}
PlotQQ(sorted_results)
```


## OLD CODE
Combine motif data with covariates and env data into a single big df
```{r, message=FALSE, warning=FALSE, echo=FALSE, results='hide'}
motifs <- unique(unlist(lapply(mat.list, colnames)))
ogs <- names(mat.list)

# Function to add missing columns with 0 values and convert to data.table
prep_dfs1 <- function(mat) {
  original_rownames <- rownames(mat)
  missing_cols <- setdiff(motifs, colnames(mat))
  
  # Create a matrix of zeros for missing columns
  zero_mat <- matrix(0, nrow = nrow(mat), ncol = length(missing_cols))
  colnames(zero_mat) <- missing_cols
  # Bind the matrices
  mat <- cbind(mat, zero_mat)
  # Order columns to match motifs
  mat <- mat[, motifs, drop = FALSE]
  dt <- as.data.table(mat)
  dt[, assemblyID := original_rownames]
  setkey(dt, assemblyID)
  return(dt)
}

# Function to add taxa and orthogroup ID columns
prep_dfs2 <- function(dt, OG_name) {
  dt[, OG := OG_name]
  return(dt)
}

# Number of cores to use
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
clusterExport(cl, c("motifs", "prep_dfs1", "prep_dfs2"))
clusterEvalQ(cl, library(data.table))

df_list_filled <- parLapply(cl, mat.list, prep_dfs1)
names(df_list_filled) <- ogs
stopCluster(cl)

# Export the filled list to the cluster environment
cl <- makeCluster(num_cores)
clusterExport(cl, c("df_list_filled", "prep_dfs2"))
clusterEvalQ(cl, library(data.table))

dfs.without.env <- parLapply(cl, names(df_list_filled), function(df_name) {
  prep_dfs2(df_list_filled[[df_name]], df_name)
})

stopCluster(cl)

combined_dt <- rbindlist(dfs.without.env, use.names = TRUE, fill = TRUE)
# Filter out assemblies with < 1000s OGs present
taxa.to.filter.out <- read.csv("/workdir/coh22/andro_tfbs/lists/fewerThan1000ogs.txt", header = F)

# Optional:filter out non-andropogoneae
andros <- filter(taxonomy, isAndro=="y")
filtered.poaceae.motifs <- filter(combined_dt, !assemblyID %in% taxa.to.filter.out$V1)
filtered.andro.motifs <- filter(filtered.motifs, assemblyID %in% andros$assemblyID)

filtered.motifs <- filtered.andro.motifs
setkey(filtered.motifs, assemblyID)

```

Calculate average motif density per assembly to include as covariate
``` {r}
all.motifs.by.taxa <- split(filtered.motifs, filtered.motifs$assemblyID)
og.counts <- lapply(all.motifs.by.taxa, nrow)

calculateMotifOccurrenceRate <- function(mat, og.count) {
  # Sum motifs across all orthogroups
  #sums <- colSums(mat[,3:ncol(mat)]) # for candidate list
  sums <- colSums(mat[,1:(ncol(mat) - 2)]) # For all motifs
  # Divide by number of orthogroups represented in the species
  occurrence.rates <- sums / og.count
  # join with assemblyID
  results <- c(mat$assemblyID[1], occurrence.rates)
  names(results)[1] <- "assemblyID"
  return(results)
}

all.motif.occurrence.list <- mapply(calculateMotifOccurrenceRate,  all.motifs.by.taxa, og.counts)
all.motif.occurrence.rates <- as.data.frame(t(all.motif.occurrence.list)) 
all.motif.occurrence.rates[, -1] <- sapply(all.motif.occurrence.rates[, -1], as.numeric)

# Normalize occurrence rates:
# Function to normalize a column
z_score_normalize <- function(x) {
  return ((x - mean(x)) / sd(x))
}

occurrence_normalized <- all.motif.occurrence.rates
occurrence_normalized[, -1] <- as.data.frame(lapply(occurrence_normalized[, -1], z_score_normalize))
occurrence_normalized <- occurrence_normalized %>%
  mutate(mean_occurrence = apply(occurrence_normalized[, 2:44], 1, mean, na.rm = TRUE))

# Plot density on tree
source("/workdir/coh22/andro_tfbs/src/PlotTraitsOnTree.R")

pdf("/workdir/coh22/andro_tfbs/results/figures/motifMeanOccurrence_unlabeled.pdf", 14,20)
plotTraitOnTree(trait= occurrence_normalized$mean_occurrence, taxa = occurrence_normalized$assemblyID, tree = tree, visible_tip_labels = F, shape = "phylogram", colors = c("#276419","white", "#8e0152"))
dev.off()

```

Run models associating global occurrence rates with environment
``` {r}
library(dplyr)
library(asreml)
library(data.table)

# Prep environmental data as response variable
EnvTrait <- env$envPC_1
names(EnvTrait) <- env$assemblyID

# Generate nucFreq PCs as covariates
nucPC <- dudi.pca(nucFreqs[,-21], scannf = FALSE, nf = 20)
fviz_eig(nucPC) # See how much variance is explained by each PC axis - first explains 70%, first five explain nearly all
nucPCaxes <- nucPC$li[1:5]
rownames(nucPCaxes) <- nucFreqs$assemblyID
colnames(nucPCaxes) <- paste0("nucPC", 1:5)
nucPCaxes$assemblyID <- nucFreqs$assemblyID

# Find common taxa represented in motif, phyloK, and environment datasets
common_rows <- base::intersect(rownames(occurrence_normalized), rownames(phyloK)) %>%
  base::intersect(names(EnvTrait)) %>%
  base::intersect(nucPCaxes$assemblyID)   %>%
  sort()

# Filter to retain taxa shared across datasets
EnvTrait_filtered <- EnvTrait[common_rows]
occurrence_filtered <- occurrence_normalized[common_rows,]
nucPCs_filtered <- nucPCaxes[common_rows,]
Kphylo_filtered <- phyloK[common_rows, common_rows]
input_mat <- as.data.frame(cbind(EnvTrait_filtered, occurrence_filtered)) %>%
  left_join(nucPCs_filtered)
input_mat$assemblyID <- as.factor(rownames(occurrence_filtered))
setnames(input_mat, gsub("-", "_", names(input_mat))) # Remove hyphens from motif names to enable parsing by model

## Iterate over all motifs in matrix
motifModels <- list()
nMotifs <- 44
for(j in 1:nMotifs){
  motifID <- colnames(input_mat)[j+2]
  print(motifID)
  # Check if more than 1 unique value
  if(length(unique(occurrence_filtered[,j])) > 1) {
      # Run association model for each motif
      formula_str <- paste(motifID, "~ EnvTrait_filtered + mean_occurrence + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5", collapse = " ")
      formula_obj <- as.formula(formula_str)
      model <- asreml(fixed = formula_obj, random = ~ vm(assemblyID, Kphylo_filtered), ai.sing = TRUE, data = input_mat)
      # Extract model results
      modelSummary <- summary(model)
      loglik <- modelSummary$loglik
      phylo_explained <- modelSummary$varcomp$component[1]
      modelWald <- wald.asreml(model)
      motif_coeff <- model$coefficients$fixed[2]
      motif_pval <- modelWald[2,4]
      motif_explained <- modelWald[2,2]/sum(modelWald[,2])
      mean_occurrence_explained <- modelWald[3,2]/sum(modelWald[,2])
  }
  else{
    # Do not run models and assign NA  to results if no variation in motif counts
    phylo_explained <- NA
    motif_coeff <- NA
    motif_pval <- NA
    motif_explained <- NA
    mean_occurrence_explained <- NA
  }
  motifModels[[j]] <- list(motifID, phylo_explained, motif_coeff, motif_pval, motif_explained, mean_occurrence_explained)
}

# Extract p values
pvalues<- unlist(lapply(motifModels, function(x) x[[4]]))
# Get indices of the 20 lowest p-values
lowest_pvalue_indices <- order(pvalues)[1:10]
motifModels[lowest_pvalue_indices]
model_results <- matrix(unlist(motifModels), nrow = 44, ncol = 6, byrow=T) %>%
  as.data.frame() %>%
  select(motif=V1, pval=V4, coef = V3) %>%
  arrange(pval)
qq(pvalues)

# Must supply named cols/rows with assembly IDs
save(model_globalOcc_envPC1, file="/workdir/coh22/andro_tfbs/results/models/ePC1_byGlobalOccurrenceRate.RData")
```

Combine data and covariates
``` {r}
cat.data <- merge(filtered.motifs, env[,c(286:287,326)], by = "assemblyID", all.x = TRUE) %>%
  left_join(occurrence_normalized[,c(1,46)])

cat.data <- na.omit(cat.data)
cat.data[, OG := as.factor(OG)]
cat.data[, assemblyID := as.factor(assemblyID)]

cat.data <- cat.data[assemblyID %in% rownames(phyloK)]

# Optionally convert column names
setnames(cat.data, gsub("-", "_", names(cat.data)))

# Remove unneeded objects to save space
#rm(combined_df, df_list_filled, dfs.without.env)
gc()
```


Run one big model with lm using phyloPCs and nuc Freq PCs
``` {r}
library(ade4)
library(factoextra)

# GEnerate phylo PCs
phyloPC <- phyloK %>%
  dudi.pca(scannf = F, nf = 20)
fviz_eig(phyloPC) # See how much variance is explained by each PC axis - first explains 85%
phyloPCaxes <- phyloPC$li[1:5]
rownames(phyloPCaxes) <- rownames(phyloK)
colnames(phyloPCaxes) <- paste0("phyloPC", 1:5)

# Generate nucFreq PCs
nucPC <- dudi.pca(nucFreqs[,-21], scannf = FALSE, nf = 20)
fviz_eig(nucPC) # See how much variance is explained by each PC axis - first explains 70%, first five explain nearly all
nucPCaxes <- nucPC$li[1:5]
rownames(nucPCaxes) <- nucFreqs$assemblyID
colnames(nucPCaxes) <- paste0("nucPC", 1:5)
nucPCaxes$assemblyID <- nucFreqs$assemblyID
big.model.data <- phyloPCaxes %>%
  mutate(assemblyID = rownames(.)) %>%
  merge(nucPCaxes) %>%
  merge(metadata) %>%
  merge(cat.data)

# Binarize counts
binarized.cat.data <- big.model.data[,22:65]
binarized.cat.data <- ifelse(binarized.cat.data != 0, 1, 0)
colnames(binarized.cat.data) <- paste0(colnames(binarized.cat.data), "_binarized")
binarized_plus_counts <- cbind(big.model.data, binarized.cat.data)


main_effects <- colnames(big.model.data)[22:65]
combinations <- combn(main_effects, 2, simplify = F)

# Get main effects and combinations for binarized terms
binarized_effects <- paste(colnames(binarized.cat.data), collapse = " + ")
binarized_combinations <- combn(colnames(binarized.cat.data), 2, simplify = F)
binarized_interaction_terms <- unlist(lapply(binarized_combinations, function(x) paste(x, collapse = ":")))
formula_str_allBinary <- paste("envPC_1 ~ mean_occurrence + phyloPC1 + phyloPC2 + phyloPC3 + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5 + (", binarized_effects, ")^2")
formula_obj_all_binary <- as.formula(formula_str_allBinary)

formula_str_binarizedInteractions <- paste("envPC_1 ~ mean_occurrence + phyloPC1 + phyloPC2 + phyloPC3 + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5 + ", paste(c(main_effects, binarized_interaction_terms), collapse = " + "))
formula_obj_binarized_interactions <- as.formula(formula_str_binarizedInteractions)

# Create interaction terms
interaction_terms <- unlist(lapply(combinations, function(x) paste(x, collapse = ":")))
formula_str_counts <- paste("envPC_1 ~ mean_occurrence + phyloPC1 + phyloPC2 + phyloPC3 + phyloPC4 + phyloPC5 + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5 +", paste(c(main_effects, interaction_terms), collapse = " + "))
options(expressions = 500000)
formula_obj_counts <- as.formula(formula_str_counts)


# Run models and save
ePC1_lm_aggregated_counts <- lm(formula_obj_counts, big.model.data)
save(ePC1_lm_aggregated_counts,file="/workdir/coh22/andro_tfbs/results/models/ePC1_lm_aggregated_counts_nucPhyloDensity.RData")

#ePC1_lm_aggregated_binary <- lm(formula_obj_all_binary, binarized_plus_counts)
#save(ePC1_lm_aggregated_binary,file="/workdir/coh22/andro_tfbs/results/models/ePC1_lm_aggregated_binarized_nucPhyloDensity.RData")

ePC1_lm_aggregated_binarized_interactions <- lm(formula_obj_binarized_interactions, binarized_plus_counts)
save(ePC1_lm_aggregated_binarized_interactions,file="/workdir/coh22/andro_tfbs/results/models/ePC1_lm_aggregated_binarizedInteractions_nucPhyloDensity.RData")

# Life history model
lh_formula_str_allBinary <- paste("envPC_1 ~ mean_occurrence + phyloPC1 + phyloPC2 + phyloPC3 + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5 + (", binarized_effects, ")^2")
formula_obj_all_binary <- as.formula(formula_str_allBinary)
lifeHistory_lm_aggregated_counts <- lm()
```
Plot model results
```{r}
load("/workdir/coh22/andro_tfbs/results/models/ePC1_lm_aggregated_binarized_nucPhyloDensity.RData")
p_values_ePC1 <- summary(ePC1_lm_aggregated_binarized_interactions)$coefficients[, 4][-c(1:13)]

sort(p_values_ePC1, decreasing = F)[1:20]
par(mfrow=c(1,2))
qq(p_values_ePC1[1:44], ylim = c(0,20))
qq(p_values_ePC1[45:length(p_values_ePC1)],ylim = c(0,20))
```
Plot heatmap of top candidates
``` {r}
# Plot heatmap of p values
heatmap_pvals <- -log10(p_values_ePC1)
names(heatmap_pvals) <- gsub("_binarized", "", names(heatmap_pvals))
names(heatmap_pvals)[1:44] <- paste0(names(heatmap_pvals)[1:44], ":",names(heatmap_pvals)[1:44], sep = "")
# Creating an empty 46x46 matrix
tf_names <- unique(unlist(strsplit(names(heatmap_pvals), split = ":", fixed = TRUE)))
pval_mat <- matrix(0, nrow = 44, ncol = 44, dimnames = list(tf_names, tf_names))
# Filling the matrix
for (name in names(heatmap_pvals)) {
  tf_pair <- strsplit(name, split = ":", fixed = TRUE)[[1]]
  pval_mat[tf_pair[1], tf_pair[2]] <- heatmap_pvals[name]
  pval_mat[tf_pair[2], tf_pair[1]] <- heatmap_pvals[name]  # if the matrix is symmetric
}
# Sorting the row and column names alphabetically
sorted_names <- sort(rownames(pval_mat))

# Reordering the matrix based on the sorted names
pval_mat_sorted <- pval_mat[sorted_names, sorted_names]

# Assigning sorted names to row and column names
rownames(pval_mat_sorted) <- sorted_names
colnames(pval_mat_sorted) <- sorted_names
# Create heatmaps
binary_colors <- c("snow2", "seagreen")
breaks <- c(min(pval_mat_sorted), 4, max(pval_mat_sorted))
#pval_mat[lower.tri(pval_mat)] <- 0

pheatmap(pval_mat_sorted, cluster_rows = F, cluster_cols = F, color = binary_colors, breaks = breaks)


```

Plot occurrence rates of top candidates

``` {r}
# Pull out candidates from matrix
# Subset to candidate TFs and interactions
candidate_interactions <- combined_dt %>%
  dplyr::select(c(assemblyID, OG, HDZIP_PLINC_AHL, SPL_B, WRKY, CPP, ERF_DREB_B, ABI, EIL4, RVE_ARR_GATA, HSF_GARP, BHLH_CAMTA)) %>%
  mutate(WRKY.CPP = ifelse(WRKY > 0 & CPP > 0, 1, 0)) %>%
  mutate(HDZIP_PLINC_AHL.CPP = ifelse(HDZIP_PLINC_AHL > 0 & CPP > 0, 1, 0)) %>%
  mutate(ERF_DREB_B.CPP = ifelse(ERF_DREB_B > 0 & CPP > 0, 1, 0)) %>%
  mutate(ABI.CPP = ifelse(ABI > 0 & CPP > 0, 1, 0)) %>%
  mutate(RVE_ARR_GATA.BHLH_CAMTA = ifelse(RVE_ARR_GATA > 0 & BHLH_CAMTA > 0, 1, 0)) %>%
  mutate(HDZIP_PLINC_AHL.EIL4 = ifelse(HDZIP_PLINC_AHL > 0 & EIL4 > 0, 1, 0)) %>%
  mutate(RVE_ARR_GATA.HSF_GARP = ifelse(RVE_ARR_GATA > 0 & HSF_GARP > 0, 1, 0)) %>%
  mutate(HSF_GARP.ABI = ifelse(HSF_GARP > 0 & ABI > 0, 1, 0))

candidate.list.by.taxa <- split(candidate_interactions,
                              candidate_interactions$assemblyID)
og.counts <- lapply(candidate.list.by.taxa, nrow)
all.motifs.by.taxa <- split(combined_dt,combined_dt$assemblyID )
# Calculate average motif occurrence per promoter
calculateMotifOccurrenceRate <- function(mat, og.count) {
  # Sum motifs across all orthogroups
  #sums <- colSums(mat[,3:ncol(mat)]) # for candidate list
  sums <- colSums(mat[,1:(ncol(mat) - 2)]) # For all motifs
  # Divide by number of orthogroups represented in the species
  occurrence.rates <- sums / og.count
  # join with assemblyID
  results <- c(mat$assemblyID[1], occurrence.rates)
  names(results)[1] <- "assemblyID"
  return(results)
}
#candidate.occurrence.list <- mapply(calculateMotifOccurrenceRate,  candidate.list.by.taxa, og.counts)
all.motif.occurrence.list <- mapply(calculateMotifOccurrenceRate,  all.motifs.by.taxa, og.counts)
all.motif.occurrence.rates <- as.data.frame(t(all.motif.occurrence.list))
all.motif.occurrence.rates[, -1] <- sapply(all.motif.occurrence.rates[, -1], as.numeric)

# Normalize occurrence rates:
# Function to normalize a column
z_score_normalize <- function(x) {
  return ((x - mean(x)) / sd(x))
}

occurrence_normalized <- all.motif.occurrence.rates
occurrence_normalized[, -1] <- as.data.frame(lapply(occurrence_normalized[, -1], z_score_normalize))

# Apply the function to each column in the dataframe

#adjusted.occurrences <- as.data.frame(t(adjusted.occurrence.list)) %>%
  #filter(!assemblyID=="MCRTL043")


# Ridgeline plot of motif cluster distributions
occurrences_long <- occurrence_normalized %>%
  pivot_longer(
    cols = -1, # Pivot all columns except the first
    names_to = "motif.cluster", 
    values_to = "occurrence.rate"
  )

# Assuming df_long is your pivoted data frame
ggplot(occurrences_long, aes(x = occurrence.rate, y = fct_rev(motif.cluster), fill = motif.cluster)) +
  geom_density_ridges() +
  theme_ridges() + 
  theme(legend.position = "none") +
  labs(title = "Ridgeline Plot of Occurrence Rates by Motif Cluster",
       x = "Standarized Occurrence Rate",
       y = "Motif Cluster") +
  xlim(c(-1,1))


# COmpute median and coefficient of variation for motifs
# Function to calculate the coefficient of variation
coefficient_of_variation <- function(x) {
  return (sd(x) / mean(x))
}

# Calculate the medians for each column
medians <- sapply(all.motif.occurrence.rates[, -1], median, na.rm = TRUE)
# Calculate the coefficients of variation for each column
coefficients_of_variation <- sapply(all.motif.occurrence.rates[, -1], function(x) {
  if(is.numeric(x)) {
    coefficient_of_variation(x)
  } else {
    NA
  }
})

# Combine the results into a dataframe
results <- data.frame(
  Motif_cluster = names(all.motif.occurrence.rates[, -1]),
  Median = medians,
  Coefficient_of_Variation = coefficients_of_variation
)

plot <- ggplot(results, aes(x = Median, y = Coefficient_of_Variation, label = Motif_cluster)) +
  geom_point(color = "blue", size = 3) +
  geom_text(vjust = -1, size = 3) +
  theme_minimal() +
  labs(
    title = "Motif cluster abundance and variability",
    x = "Median occurrence rate (per 500bp upstream region)",
    y = "Coefficient of Variation"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

# Print the plot
print(plot)
```


``` {r}
# Plot occurrences on tree
source("/workdir/coh22/andro_tfbs/src/PlotTraitsOnTree.R")

pdf("/workdir/coh22/andro_tfbs/results/figures/blankTree.pdf", 14,20)
plotTraitOnTree(trait= nucFreqs$A + nucFreqs$T, taxa = nucFreqs$assemblyID, tree = tree, visible_tip_labels = F, shape = "phylogram", colors = c("snow3", "snow3"))
dev.off()
```

``` {r}
# Test significance of top candidates
phyloPCaxes$assemblyID <- rownames(phyloPCaxes)
occurrence.env <- left_join(adjusted.occurrences, env) %>%
  left_join(phyloPCaxes) %>%
  left_join(nucPCaxes) %>%
  na.omit()

WRKY.CPP <- lm(envPC_1 ~ WRKY.CPP + phyloPC1 + phyloPC2 + phyloPC3 + phyloPC4 + phyloPC5 + 
                     nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5, data = occurrence.env)
ERF_DREB_B <- lm(envPC_1 ~ ERF_DREB_B + phyloPC1 + phyloPC2 + phyloPC3 + phyloPC4 + phyloPC5 + 
                     nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5, data = occurrence.env)
library(asreml)
global_for_model <- mutate(occurrence.env, assemblyID = as.factor(assemblyID))
WRKY.CPP.mixedModel <- asreml(WRKY.CPP ~ envPC_1 + nucPC1 + nucPC2 + nucPC3 + nucPC4 + nucPC5, random = ~ vm(assemblyID, phyloK) , ai.sing = TRUE, data = global_for_model)
modelSummary <- summary(WRKY.CPP.mixedModel)
loglik <- modelSummary$loglik
phylo_explained <- modelSummary$varcomp$component[1]
modelWald <- wald.asreml(WRKY.CPP.mixedModel)
motif_coeff <- WRKY.CPP.mixedModel$coefficients$fixed[2]
motif_pval <- modelWald[2,4]
motif_explained <- modelWald[2,2]/sum(modelWald[,2])
```
Set up function in ASREML for one big model
```{r}
# Try with 1/10th of data
cat.data.mini <- cat.data[sample(nrow(cat.data), nrow(cat.data) * 0.1), ]

# Prep model terms
main_effects <- colnames(cat.data)[2:45]
combinations <- combn(main_effects, 2, simplify = F)

# Create interaction terms
interaction_terms <- unlist(lapply(combinations, function(x) paste(x, collapse = ":")))

# Convert the terms string to a formula
formula_str <- paste("envPC_1 ~ ", paste(c(main_effects, interaction_terms), collapse = " + "))
#formula_str <- paste("envPC_1 ~ ", paste(c(main_effects), collapse = " + "))
options(expressions = 500000)
formula_obj <- as.formula(formula_str)

# Print the formula to check
print(formula_obj)

library(asreml)
asreml.options(verbose = FALSE, workspace="20000mb")

# Increase stack size
options(expressions = 500000)
# Fit the model
#model <- asreml(envPC_1 ~ BZIP + WRKY + BZIP:WRKY, random = ~ vm(assemblyID, phyloK), ai.sing = TRUE, data = cat.data)
model <- asreml(fixed = formula_obj, random = ~ vm(assemblyID, phyloK), ai.sing = TRUE, data = cat.data.mini)

save(ePC1_asreml_aggregated_counts, file="/workdir/coh22/andro_tfbs/results/models/ePC1_WRKYmini_asreml_aggregated_counts.RData")

```







```{r}



```




